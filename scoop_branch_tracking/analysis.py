##################################################################
#   Analysis for data generated by main function in
#   scoop_branch_tracking.
##################################################################

import sys
import os
from os.path import isfile, join
import numpy as np
import matplotlib.pyplot as plt
sys.path.append('../')
from classes.perimeter_params.tools import parameter_instantiate as hhg
from classes.unscaled_parameters.unscaledparam import unscaledparam
from classes.time_param.t_param import time_evolution_params

pltparams = {
    'axes.labelsize': 30,
    # 'legend.fontsize': 28,
    'legend.fontsize': 23,
    'xtick.labelsize': 22,
    'ytick.labelsize': 22,
    'figure.figsize': [5.2 * 3.375, 3.5 * 3.375],
    'text.usetex': True
}
plt.rcParams.update(pltparams)

"""Generate our class for the unscaled parameters"""
"""these are primarily used for saving our data"""
param = unscaledparam(L=6, t0=0.52, U=0, pbc=True, field=32.9, F0=10, a=4, a_scale=1, J_scale=1, tracking=1)

"""generating our class of scaled parameters"""
"""this is used for most of the calculations"""
lat = hhg(field=param.field, nup=param.N_up, ndown=param.N_down, nx=param.L, ny=0, U=param.U, t=param.t0, F0=param.F0
          , a=param.a, pbc=param.pbc)

"""setup our evolution time parameters"""
t_p = time_evolution_params(perimeter_params=lat, cycles=6, nsteps=int(3e3), plotting=1)

#state whether we want to look at a single branch or load in all of them
track_one = False
if track_one:
    # state which branch we want to look at
    branch_string = '00'

    # load in our preliminary data for comparison's sake
    loadfile = '../Preliminary simulation/Data/expectations:{}sites-{}up-{}down-{}t0-{}U-{}cycles-{}steps-{}pbc.npz' \
            .format(param.L, param.N_up, param.N_down, param.t0, param.U, t_p.cycles, t_p.n_steps, param.pbc)
    expectations = dict(np.load(loadfile))

    # load in tracked data with the particular branch number we want to look at
    tracking_datafile = './Data/{}sites-{}up-{}down-{}t0-{}U-{}cycles-{}steps-{}pbcF0={:.2f}-' \
                        'J_scale={:.2f}'.format(param.L, param.N_up, param.N_down, param.t0, param.U, t_p.cycles,
                                                t_p.n_steps, param.pbc, param.F0, param.J_scale)

    branch_path = '/expectations:bstring={}.npz'.format(branch_string)
    tracking_expectations = np.load(tracking_datafile + branch_path)
else:
    # initialize list for our expectations
    tracking_expectations = {}

    # load in our preliminary data for comparison's sake
    loadfile = '../Preliminary simulation/Data/expectations:{}sites-{}up-{}down-{}t0-{}U-{}cycles-{}steps-{}pbc.npz' \
        .format(param.L, param.N_up, param.N_down, param.t0, param.U, t_p.cycles, t_p.n_steps, param.pbc)
    expectations = dict(np.load(loadfile))

    # find all data files for a given set of parameters and import their names into a list
    tracking_datadir = './Data/{}sites-{}up-{}down-{}t0-{}U-{}cycles-{}steps-{}pbcF0={:.2f}-' \
                        'J_scale={:.2f}'.format(param.L, param.N_up, param.N_down, param.t0, param.U, t_p.cycles,
                                                t_p.n_steps, param.pbc, param.F0, param.J_scale)

    datafiles = [join(tracking_datadir,f) for f in os.listdir(tracking_datadir) if isfile(join(tracking_datadir, f))]

    # for all files in this directory, import a dictionary for all the branches
    for f in datafiles:
        tracking_expectations.update(np.load(f))

"""plot out expectations"""
if track_one:
    """Plotting field"""
    plt.figure("Control field")
    plt.xlabel("Time (cycles)")
    plt.ylabel("$\\Phi(t)$")
    plt.grid(True)
    plt.tight_layout()
    plt.plot(t_p.times, expectations['phi'])
    plt.plot(t_p.times, tracking_expectations['tracking_phi'+branch_string], ".")
    plt.show()

else:
    print(tracking_expectations)
    """Plotting field"""
    plt.figure("Control field")
    plt.xlabel("Time (cycles)")
    plt.ylabel("$\\Phi(t)$")
    plt.grid(True)
    plt.tight_layout()
    plt.plot(t_p.times, expectations['phi'])
    plt.plot(t_p.times, tracking_expectations['tracking_phi0'], ".")
    plt.plot(t_p.times, tracking_expectations['tracking_phi10'][:len(tracking_expectations['tracking_phi0'])], ".")
    plt.plot(t_p.times, tracking_expectations['tracking_phi11'][:len(tracking_expectations['tracking_phi0'])], ".")
    plt.show()

    """Plotting Current"""
    plt.figure("Current")
    plt.xlabel("Time (cycles)")
    plt.ylabel("$J(t)$")
    plt.grid(True)
    plt.tight_layout()
    plt.plot(t_p.times, expectations['current'])
    plt.plot(t_p.times, tracking_expectations['tracking_current0'], ".")
    plt.plot(t_p.times, tracking_expectations['tracking_current10'][:len(tracking_expectations['tracking_phi0'])], ".")
    plt.plot(t_p.times, tracking_expectations['tracking_current11'][:len(tracking_expectations['tracking_phi0'])], ".")
    plt.show()

    """Plotting field"""
    plt.figure("Control field")
    plt.xlabel("Time (cycles)")
    plt.ylabel("$\\Phi(t)$")
    plt.grid(True)
    plt.tight_layout()
    plt.plot(t_p.times, expectations['phi'])
    plt.plot(t_p.times, tracking_expectations['tracking_phi0'], ".")
    plt.plot(t_p.times, tracking_expectations['tracking_phi10'][:len(tracking_expectations['tracking_phi0'])], ".")
    plt.plot(t_p.times, tracking_expectations['tracking_phi11'][:len(tracking_expectations['tracking_phi0'])], ".")
    plt.show()